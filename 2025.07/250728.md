* SQL
  * pymysql 로 DB 연결
    * select 해서 데이터를 가져와서 pandas Dataframe 에 저장하면 의도하지 않은 타입으로 저장될 수 있기 때문에,
    * dataframe info 를 통해서 데이터 타입이 적절한지 꼭 확인하고, 맞지 않다면 원하는 타입으로 형 변환을 꼭 하자.
    * pandas 에서는 read_sql 기능이 있음
    * 여러 SQL 문장을 하나의 execute 에서 실행하는 방법
      * from pymysql.constants import CLIENT
      * client_flag=CLIENT.MULTI_STATEMENTS // pymysql.connect 에서 실행할 때
      * 여러 문장을 한꺼번에 보낸 결과를 확인할 때는 cursor.nextset() 를 사용한다.
      * 다음 동작이 있으면 True 가 표시되고,
      * 이 때 cursor 에 대해서 fetchall 을 하면 됨.
      * 멀티 쿼리를 사용하면, 한번의 네트워크 요청으로 여러 SQL 을 서버에 전송하고, 결과도 한번에 받아올 수 있으니까 네트워크 왕복 횟수가 1회로 줄어듦
      * 여러 SQL 문을 서버로 보내기 때문에 네트워크 비용은 줄지만,
      * 서버 입장에서는 여전히 각각의 insert 문을 따로 처리
      * 진짜 bulk insert 는 cursor.executemany 를 사용하는 것이다. 또는 insert 문에 다중 values 를 이용
    * 동적 SQL 을 사용하려면, 변경되는 자리에 %s 를 채워줍니다. %s 개수만큼 cursor execute 에서 '리스트'나 '튜플' 형태로 입력한다.
      * 이 떄, 작은 따옴표 대신 큰 따옴표를 사용한다는 것을 기억
      * 웬만하면 python 단에서 처리하는 것이 필요
      * f-string 으로 써도 괜찮다.
    * dataFrame 을 DB 로 보낼 때 ORM 사용 (alchemy)
      * from sqlalchemy import create_engine  # InnoDB
      * engine = create_engine(f"mysql+pymysql://{USER}:{PASSWD}@{HOST}:{PORT}/fisa?utfmb4")
      * df.to_sql(name='emp02', con=engine, if_exists='fail', index=True)
        * if_exists : fail // 이미 있으면 실패
        * replace : 새로 쓰기
        * append : 이어쓰기
* Docker
  * docker image 를 미리 만들어놓고, 서버 리소스가 부족하면 자동으로 스케일 아웃이 될 수 있도록 함.
  * 컨테이너: 다른 프로세스와 격리된 상태로 OS 에서 SW 를 실행하는 기술
  * "하나의 OS" 위에서 각각의 컨테이너 운영 : docker // 컨테이너형 가상화
    * 호스트 OS 의 커널을 공유한 경량 가상화를 제공해서 더 나은 리소스 활용과 더 빠른 배포가 가능
  * 하드웨어의 전체 가상화를 제공, 여러개의 독립적인 OS 실행을 허용 : 하이퍼바이저형 가상화
    * 컨테이너형에 비해 오버헤드가 큼
  * docker images
    * image id 를 통해서 최신 업데이트된 이미지를 가져올 수 있다.
  * docker-compose : 여러 컨테이너를 관리하고 실행하는데 사용되는 명령어
  * docker 명령어를 제어할 때 container id 나 name 을 이용할 수 있다.
  * docker --name 으로 고정된 이름으로 지정할 수 있다.
  * docker run --name nginx_test -d -p 8001:80 public.ecr.aws/nginx/nginx
    * 호스트 포트를 컨테이너 포트와 매핑도 가능하다.
  * docker 는 생명주기가 있음. create 생성은 정상적으로 되었으나, run 이 제대로 안되는 가능성도 있다.
  * 컨테이너는 일회성이다. 가동 중에 무언가 수정했더라도 재시작하면 모두 날라감.
    * 컨테이너가 날아가더라도 v 옵션을 통해서 디렉토리 마운팅을 해놓으면 남아있다.
  * it 명령어: 인터랙티브 모드로 실행, 터미널 입력을 받을 수 있음
    * docker exec -it nginx_test4 bash
* 기타
  * pd.options.display.float_format = '{:.2f}'.format
  * 복습
    * python 은 인터프리터 언어이고, 소스코드를 바이트 코드 (.pyc) 로 컴파일한 후 인터프리터 python virtual machine PVM 을 실행한다.
    * Box plot 은 데이터의 분포와 함께 사분위수, 중앙값, 그리고 이상치 (Outliers) 를 명확히 시각화할 수 있는 도구임.
    * pandas dataframe iloc 은 정수 기반 위치 인덱싱으로 예를 들어 df.iloc[0] 은 0번째 행을 선택합니다.
      * 비교해서 df.loc[0] 은 레이블 기반 인덱싱으로 인덱스 값이 0인 행이 있다면 선택함.
    * SQL 트리거
      * 테이블에 부착되어 자동으로 실행되는 객체로 execute trigger 와 같이 트리거를 직접 실행할 수 없음.
      * 트리거는 물리적 테이블에만 부착이 가능해서, 뷰 View 에는 사용할 수 없음
      * 부착한 테이블의 before  / after 상태를 활용해 사용
      * OLD, NEW 키워드를 사용해 OLD.column_name, NEW.column_name 형식으로 접근해서 변경 전/후 값을 활용할 수 있음
    * MySQL unique
      * null 값을 허용해 중복으로 간주하지 않음
      * 클러스터 인덱스는 PK 와 관련돼 있음
    * MySQL 쿼리 실행 순서
      * FROM : 테이블 / 뷰 등 소스 데이터 READ
      * ON (for JOIN) : 조인 조건을 필터링
      * JOIN : 테이블 결합
      * WHERE : 조건에 맞는 행 필터링
      * GROUP BY : 그룹 단위로 묶음
      * HAVING : 그룹핑 데이터에 대한 조건 필터링
      * SELECT : 최종 컬럼 조회
      * DISTINCT : 중복 제거
      * ORDER BY : 정렬
      * LIMIT : 결과 행 제한
    * 함수 / 프로시저
      * 함수는 SELECT 에서 호출할 수 있지만, 프로시저는 SELECT 에서 직접 호출할 수 없고, CALL 명령어로 별도 호출
      * 프로시저는 값을 반환하지 않아도 되지만, 함수는 반드시 RETURN 을 사용해 값을 반환
      * 트리거에서는 함수를 호출할 수 있으나, 프로시저를 호출할 수 없음
      * 프로시저는 IN, OUT, INPUT 파라미터 모두 허용 // 함수는 IN 파라미터만 허용하고, RETURN 으로만 함.
    * Pandas
      * db select 결과를 dataFrame 으로 읽을 떄, 컬럼명을 DB에서 가져온 그대로 유지하려면 read_sql() 을 사용
        * cursor.description 을 사용할 수도 있음
      * dataFrame 에서 datetime 타입은 dt.hour / dt.weekday 로 날짜 정보를 접근할 수 있음
      * 각 컬럼에 대한 집계를 할 때 value_counts() 를 이용 // Series 형태여서
        * 결과를 DataFrame 으로 얻고 싶을 때는 groupby() + size() + reset_index() 를 이용
      * 사용자별 이벤트 수 집계: pivot
        ```python
        # (예시)
        pivot = df.pivot_table(
             index='user_id', 
             columns='event_type', 
             values='event_type', 
             aggfunc='count', 
             fill_value=0
       )
        ```
