## 25. 7. 9 (Wed)

* 클래스
  * 추상화, 상속, 다형성, 캡슐화(은닉화)
  * 클래스는 설계도, 객체는 설계도를 이용해 지은 집
    * 클래스 안에서 사용하기 위한 변수 (클래스 변수, 공유 변수)
    * 클래스에서 사용하는 메소드 (클래스 메소드)
    * 각각 고유한 인스턴스 안에서 사용하기 위한 변수 : 인스턴스 변수
    * 인스턴스 메소드
    * 개발자가 인스턴스를 통해 클래스변수에 접근하는 것을 지양한다.
    * 파이썬은 인스턴스 안에서 메소드를 호출할 때 자체적으로 인터프리터가 self 를 인자로 추가한다.
    * 클래스 메소드에는 @classmethod 어노테이션을 추가하고, cls 는 약속된 인자명이다.
      * self, cls
      * <class '__main__.Car'> # print(cls)
      * <__main__.Car object at 0x7b32f08bb5d0> # Car 에서 생성된 인스턴스인데, 메모리 주소가 새로 생성되었어!
    * @staticmethod
      * 중립적인, 클래스/인스턴스에 구애받지 않지만 필요한 함수
    * 클래스 변수에 인스턴스로 접근되는 것과 같은 원리 (얕은 복사) - 권장되지 않음
    * 모닝.car_info() # car_info(self) 인스턴스메소드를 인스턴스로 접근 - '사과나무'.find('무')
    * color: list = ['white', 'black', 'blue'] # 공유변수로 기능 (차원이 여러개일 때 의도치 않게 인스턴스 변수를 바꿨는데 클래스변수를 훼손)
      * 얕은 복사가 되고 list 는 mutable 하기 때문에
    * Car 상속받은 Bike 가 고유한 name, total_name 클래스 변수를 가지려면 init 을 수정해야함.
      * (중요) 상속을 하기 위한 방식으로 재사용을 고려하자
        * Car 대신에 type(self)
      * 상속받은 Bike \__init\__() 에서 super().\__init\__(name, displacement, is_kor, ...)
        * 이외에 is_tuned 만 추가하는 방법도 있다.
        * super 는 부모클래스를 호출해서 부모가 갖고 있는 변수/메소드를 가져온다.
        * 보다 단순한 표기법.. def \__init\__(self, is_tuned:bool = False, *args, **kwargs):
          * super().__init__(*args, **kwargs)
          * self.is_tuned = is_tuned
      * greater than gt 를 구현하면, lt (<) 자동 구현
    * python class 에서 __ 로 시작하는 변수명을 작성하면 내부적으로만 사용한다는 의미 (mangling / 맹글링)
      _ 클래스명 __ 변수명으로 변경해줌
    * @property 동작(함수) 를 값(변수) 처럼 사용하게 하는 데코레이터
      * __ call __ 기능을 뺐어간다. 변수처럼 만든 함수는 getter 만 가능
      * setter 는 @get_pw setter 로 표기할 수 있다.
      * @property 는 내부 구현은 숨기고, 변수처럼 자연스럽게 접근할 수 있게 해주는 장치, 은닉성과 인터페이스의 분리를 도와줌
      * 은닉성
        * 내부 구현 (데이터 구조나 처리 방식) 을 외부에서 직접 접근하지 못하도록 보호
        * 사용자 (다른 객체, 외부 코드) 는 공식적인 인터페이스 (메소드, 속성) 만을 통해 객체와 상호작용한다.
    * 클래스와의 관계
      * is-a 관계 (상속 관계)
      * has-a 관계 (객체 내에서 새로 인스턴스를 생성해서 해당 클래스의 속성/메소드를 사용할 수 있는 관계)
    * 파이썬에서는 다중상속 가능, Java 는 다중상속을 허용하지 않는다.
