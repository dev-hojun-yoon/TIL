* docker
  * docker exec -it -e LC_ALL=C.UTF-8 nginx_test4 bash 에서 -e 에는 환경변수가 들어간다.
  * docker run --name nginx_test4 -d -p 8003:80 -v {호스트 경로}:/usr/share/nginx/html/ public.ecr.aws/nginx/nginx:stable-perl
    * -v mount 를 통해 파일 수정 등 현재 상태가 공유된다. // bind mount
  * jupyter/datascience-notebook
    * jupyter : 레파지토리
    * datascience-notebook : 세부 저장소
    * jupyter/base-notebook 내용이 위 저장소에 포함되어 있다.
  * 빌드 과정
    * 업데이트해야할 부분을 먼저 배치하면 효율화
  * docker logs {container id}
    * 이상이 있는지 확인
  * docker image 삭제
    * docker rmi jupyter/datascience-notebook
      * 단순히 rm 은 컨테이너를 삭제하는 것이다.
    * docker image rm <imagee_id> or docker rmi <image명>
    * 사용 중인 이미지 삭제 시 에러 주의
  * docker start {컨테이너 ID}
    * stop 후에 재시작 할 때 -d 백그라운드로 실행할 수 없음
  * docker run --name docker-nginx -p 80:80 public.ecr.aws/nginx/nginx:stable-perl
  * docker exec <container_id> sh -c 'curl localhost'
  * docker exec docker-nginx sh -c 'cat /usr/share/nginx/html/index.html'   # 컨테이너 안에 들어가지 않고 컨테이너에게 명령
  * docker 명령어 참고
    ```
    $docker ps -a
    $docker image ls
    $docker pull nginx
    $docker ps
    $docker image ls
    $docker run --name docker-nginx -p 80:80 public.ecr.aws/nginx/nginx:stable-perl
    $docker ps -a
    $docker exec <container_id> sh -c 'curl localhost'
    $ docker exec docker-nginx sh -c 'cat /usr/share/nginx/html/index.html'   # 컨테이너 안에 들어가지 않고 컨테이너에게 명령을 내립니다.
    $docker stop <container_id>
    $docker start<container_id>
    $docker ps -a
    $docker container ls
    $docker rm <container_id>
    $docker container ls
    $docker image ls
    $docker image rm <imagee_id> or docker rmi <image명>
    $docker image ls
    ```
  * 파일 복사
    * docker cp index.html docker-nginx:/usr/share/nginx/html/hello.txt
    * (반대도 가능) docker cp docker-nginx:/usr/share/nginx/html/ C:\ITStudy\03_docker\copy
  * Mount
    * 컨테이너 끼리 연결하기 위해서 사용하는 또는 도커가 컨테이너를 관리하기 위한 공간으로 사용: 볼륨 마운트
    * docker volume create test-volume
    * docker volume inspect test-volume
    * docker run -it -p 83:80 -v test-volume:/usr/share/nginx/html nginx
      * 물리적인 디렉토리가 아니라, 가상 공간임.
    * 해당 볼륨은 docker-desktop 하위에 다음 경로에 위치
      * \\wsl.localhost\docker-desktop\mnt\docker-desktop-disk\data\docker\volumes
      * 이 볼륨은 도커가 관리하는 곳
  * 볼륨 삭제
    * 참조된 컨테이너 id 를 모두 삭제한 이후에 실행
    * docker volume rm test-volume
  * Tag (Alias)
    * docker tag public.ecr.aws/nginx/nginx:stable-perl nginx
  * 도커 이미지를 만드는 방법
    * 이미지 공유 저장소
      * 
    * 모든 작업 내용을 커밋해서 이미지화
    * (일반적으로) 주문서를 통해 필요한 부분만 이미지화 docker
  * docker exec -it -e LC_ALL=C.UTF-8 nginx_test4 bash 에서 -e 에는 환경변수가 들어간다.
  * docker run --name nginx_test4 -d -p 8003:80 -v {호스트 경로}:/usr/share/nginx/html/ public.ecr.aws/nginx/nginx:stable-perl
    * -v mount 를 통해 파일 수정 등 현재 상태가 공유된다. // bind mount
  * jupyter/datascience-notebook
    * jupyter : 레파지토리
    * datascience-notebook : 세부 저장소
    * jupyter/base-notebook 내용이 위 저장소에 포함되어 있다.
  * 빌드 과정
    * 업데이트해야할 부분을 먼저 배치하면 효율화
  * docker logs {container id}
    * 이상이 있는지 확인
  * docker image 삭제
    * docker rmi jupyter/datascience-notebook
      * 단순히 rm 은 컨테이너를 삭제하는 것이다.
    * docker image rm <imagee_id> or docker rmi <image명>
    * 사용 중인 이미지 삭제 시 에러 주의
  * docker start {컨테이너 ID}
    * stop 후에 재시작 할 때 -d 백그라운드로 실행할 수 없음
  * docker run --name docker-nginx -p 80:80 public.ecr.aws/nginx/nginx:stable-perl
  * docker exec <container_id> sh -c 'curl localhost'
  * docker exec docker-nginx sh -c 'cat /usr/share/nginx/html/index.html'   # 컨테이너 안에 들어가지 않고 컨테이너에게 명령
  * docker 명령어 참고
    ```
    $docker ps -a
    $docker image ls
    $docker pull nginx
    $docker ps
    $docker image ls
    $docker run --name docker-nginx -p 80:80 public.ecr.aws/nginx/nginx:stable-perl
    $docker ps -a
    $docker exec <container_id> sh -c 'curl localhost'
    $ docker exec docker-nginx sh -c 'cat /usr/share/nginx/html/index.html'   # 컨테이너 안에 들어가지 않고 컨테이너에게 명령을 내립니다.
    $docker stop <container_id>
    $docker start<container_id>
    $docker ps -a
    $docker container ls
    $docker rm <container_id>
    $docker container ls
    $docker image ls
    $docker image rm <imagee_id> or docker rmi <image명>
    $docker image ls
    ```
  * 파일 복사
    * docker cp index.html docker-nginx:/usr/share/nginx/html/hello.txt
    * (반대도 가능) docker cp docker-nginx:/usr/share/nginx/html/ C:\ITStudy\03_docker\copy
  * Mount
    * 컨테이너 끼리 연결하기 위해서 사용하는 또는 도커가 컨테이너를 관리하기 위한 공간으로 사용: 볼륨 마운트
    * docker volume create test-volume
    * docker volume inspect test-volume
    * docker run -it -p 83:80 -v test-volume:/usr/share/nginx/html nginx
      * 물리적인 디렉토리가 아니라, 가상 공간임.
    * 해당 볼륨은 docker-desktop 하위에 다음 경로에 위치
      * \\wsl.localhost\docker-desktop\mnt\docker-desktop-disk\data\docker\volumes
      * 이 볼륨은 도커가 관리하는 곳
  * 볼륨 삭제
    * 참조된 컨테이너 id 를 모두 삭제한 이후에 실행
    * docker volume rm test-volume
  * Tag (Alias)
    * docker tag public.ecr.aws/nginx/nginx:stable-perl nginx
  * 도커 이미지를 만드는 방법
    * 마운트한 파일은 commit 시 적용되지 않는다.
      * 마운트된 경로는 overlay 된 것이라 commit 시 원본만 반영됨.
    * 이미지 공유 저장소
      * http://hub.docker.com/아이디/레포지토리명:버전명
    * 모든 작업 내용을 커밋해서 이미지화
      * 컨테이너를 우선 생성하고,
      * docker commit 컨테이너이름 새로운이미지이름
      * 이미지 이름 구성
        * [저장소]/[이미지 이름]:[태그 버전며]
      * 임시 저장을 위한 commit 이기 때문에 inspect 시 architecture, OS 정보가 비어있음.
    * (일반적으로) 주문서를 통해 필요한 부분만 이미지화
      * docker file 을 만든다.
      * 이미지 파일을 생성할 수 있는 텍스트 파일
      * docker build 을 사용하여 이미지 구성 가능
      * 주요 명령어
        * run 은 ehco hello
        * cmd 는 ["echo", "hello"] 와 같은 형태
        <img width="641" height="628" alt="image" src="https://github.com/user-attachments/assets/cf6a786a-3cce-4ade-9d0f-1fa6f7e3156b" />
        
      * docker build -t signtilde/mountcheck:1.1 . // 현재 경로에 DockerFile 기반 생성
      * inspect 시 architecture, OS 정보가 포함돼있음
      * 마운트된 경로가 연결되는 것이 아니라, 이미지에 모두 포함이 된 것이다.
      * 예시
        ```
        # docker build  -t  생성할이미지명:버전명  Dockerfile위치
        #  docker run --name yeonji --rm -d -p 호스트포트:내부포트 생성된이미지
        ## streamlit을 도커 이미지로 작성해서 외부에서 배포한다면?
        FROM 파이썬이미지(리눅스에 파이썬을 깔아놓은 상태)
        COPY requirements.txt /app 
        COPY 스트림릿 파일들  /app
        
        WORKDIR /app
        RUN pip install -r requirements.txt
        
        CMD ["streamlit", "run", "app.py"]
        
        EXPOSE 스트림릿이 배포되는 포트명 
        ```

* 기타
  * jupyter:  세 개의 핵심 언어인 Julia, Python 그리고 R 지원
  * .dockerignore : 이미지 빌드 시 무시될 정보
  * 도커 이미지 빌드 시 경량화하는 것이 중요하다.
  * aws ECR 에서 제공하는 이미지는 architecture, OS 정보가 없는 경우가 있었다. 이 경우 docker hub 에 push가 제대로 안될 수 있다. (--platform linux/amd64,linux/arm64 옵션을 추가) [한번만 적용하면 된다.]
    ```
    # 멀티 플랫폼 빌드를 위해 `buildx` 빌더를 생성하고 활성화하는 명령어
    $ docker buildx create --use  
    $ docker buildx build --platform linux/amd64,linux/arm64 -t atangi/mountcheck:0.0 --push .
    ```
