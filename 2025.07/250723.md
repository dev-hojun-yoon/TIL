* SQL
  * join 을 사용하면 join 적용하고 나서, where 을 동작한다.
  * 따라서 join 에서 조건을 마무리하는 것도 방법이다.
  * null 과 연산을 할 때 결과가 null이 되는 것을 기억, 집계함수는 null 을 제외하고 동작
  * null 과 0 은 다르다.
  * 서브 쿼리 안에서는 메인 쿼리 칼럼을 가져다 쓸 수 있지만, 메인 쿼리에서는 서브 쿼리 칼럼을 가져다 쓰려면 별도로 select 해야함.
  * from 절에 만들어진 파생 서브 쿼리는 alias 별칭을 반드시 해줘야 한다.
  * DDL : create, drop, alter
    * alter table 테이블명 / 변경사항 / 변경할 컬럼 / 칼럼명 / 자료형 / 제약 조건
  * DCL : grant, revoke
  * TCL : commit, rollback, start transaction / begin, savepoint, set autocommit
  * DML
    * select, insert, update, delete
    * emp 테이블에서 일부 필드를 emp01 테이블로 복사했을 때 (create ~ select) emp 테이블의 제약조건이 추가되지 않는다.
    * insert 문: , 구분자로 () 표현을 적용해서 저장
    * MySQL 은 인서트할 때 자동 형변환을 해주는 특징이 있다.
    * select @@autocommit; // default 이고, delete, update, insert 시에 바로 반영되는 것이 일반적이다.
      * false 로 변경되면, 트랜잭션 단위로 commit 을 작성할 때까지 실제 db 에 반영되지 않는 상태
      * start transaction ~ commit 사이의 트랜잭션에서 수행하는 내용을 정의
      * transaction 사이에 savepoint sp1 와 같이 위치를 설정할 수 있고, rollback 과 연계해서 rollback to savepoint sp2 를 통해 해당 시점으로 전환될 수 있음
      * commit 후에는 rollback 이 적용 불가함.
      * rollback 하면 start transaction 이전 상태로 전환됨.
      * MySQL 은 데이터변경을 함
      * 부로 하지 않게 commit 하기 전까지 임시로 각 접속자마다 세션을 관리해서 commit 으로 한꺼번에 해당 쿼리문을 db 에 적용한다. 이 적용 단위를 트랜잭션이라함.
      * 한 줄씩 반영하지 않으니 네트워크 비용을 아낄 수 있을 것이다.
      * update 구문에서는 join 이 update 테이블명 join 중복 칼럼명 set 칼럼 = 변경할값
    * upsert : 중복된 키에 대한 처리 // 그러나 upsert 키워드가 없는 경우가 있음
      * on duplicate key update 문법을 사용
  * DROP 은 테이블 자체를 삭제 / TRUNCATE 는 구조만 남겨놓고 행을 모두 삭제
    * truncate 는 commit 과 무관하게 반영
    * truncate: 복구 불가, 빠름, 바로 반영
    * delete from : 한 행씩 삭제, 느림
* 인덱스
  * 클러스터 인덱스와 보조 인덱스로 구분
  * 네이밍 규칙 : 기능명_테이블명_컬럼명
  * create index idx_emp01_empno on emp01(empno)
  * desc 로 확인하면 key 에 MUL (multi) 로 표기
  * primary key 에는 인덱스명을 정할 수 없음
* 기타
  * 1=0, 1=1 where 절에 있는 관용구가 있음
  * now(): 명령어가 실행된 시점 // sysdate() : 함수가 실행된 시점
  * cardinality: 고유값이 많은 곳에 인덱스 설정이 유리?
