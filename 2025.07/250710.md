## 25. 7. 10 (Thu)

* Numpy (Numeric python)
  * 1차원 배열 (벡터), 2차원 (행렬), 3차원 (시계열 데이터)
  * broadcast 방식으로 처리 속도를 높임
  * 일반 컨테이너 자료형은 데이터 변환이 번거로움
  * 자료형 ndarray (numpy dimension array)
    * 차원을 가지고 숫자와 문자열을 다루고, 동일 타입의 원소만 담겨야 함.
    * test = np.array([15, 20, 25, 30])
  * 평균 구하기: np.mean(test)
  * 수열을 만들어주는 메소드: np.arange(15, 31, 5) # 파이썬 내장 함수 range 와 비슷
  * list 는 데이터마다 방을 새로 추가하는 것이지만, ndarray 는 배열에 값을 추가하면 새로 배열을 만든다. // test = np.append(test, 35)
  * 5씩 더하기
    * [*map(lambda x: x+5, test)]
    * test + 5
  * numpy 사이즈 관한 변수들
    * itemsize # 원소가 차지하는 방의 byte 사이즈
    * dtype # 자료형
    * ndim # 차원
    * size # 원소의 전체 개수
    * shape # ndarray 의 구조 (5,) - 튜플
    * strides # 보폭 // 연산 속도가 빠를 수 있는 이유 // mmap 과 비교
  * dtype <U21 유니코드
    numpy.str_ 로 원소를 변환해줌.
  * ndarray.T 연산
    * numpy 배열 (ndarray) 전치 (transpose) 연산
      * 행과 열을 뒤바꾸는 연산임.
  * 차원이 맞지 않으면 1차원으로 결과를 리턴함
    ```python
    test = array([[[1, 2, 3]],
       [[4, 5, 6]],
       [[7, 8, 9]]])
    np.append(test, 40)
    # array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 40])
    ```
  * np.append(axis=0) 에서 axis 는 0 이 행, 1이 열이다.
  * append 분석
    (Case 1)
    ```python
    test =[[[1, 2, 3]],
       [[4, 5, 6]],
       [[7, 8, 9]]]

    test = np.array(test)
    test.shape # (3, 1, 1)

    test3 = np.array([[[1]],
     [[2]],
     [[3]]])
    test3.shape # (3, 1, 1)
    np.append(test, test3, axis=2)

    # array([[[1, 2, 3, 1]],
    #      [[4, 5, 6, 2]],
    #      [[7, 8, 9, 3]]]) 
    ```
    (3, 1, 3) 은 3개의 (1, 3) 배열 // (3, 1, 1) 3개의 (1, 1) 배열
    axis=2 는 가장 안쪽 축 (마지막 축.. 열 방향의 안쪽 원소에 대한 append)
    따라서 axis=2 는 각 (1, 3) 배열의 열 방향으로 데이터를 붙이는 것이다.
    3개의 원소에 열 하나를 추가하는 것

    (Case 2)
    ```python
    new_test = np.array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
    new_test.ndim # 2
    new_test.shape # (3, 3)

    new_test1 = np.array([[1,2,3]])
    # shape: (1, 3)

    np.append(new_test, new_test1.T, axis=1)
    # array([[1, 2, 3, 1],
    #   [4, 5, 6, 2],
    #   [7, 8, 9, 3]])
    ```
  * 유용한 메소드
    * np.ndarray.cumsum()
    * mean() # 평균
    * var() # 분산
    * std() # 표준편차
    * argmax() # 가장 큰 값의 인덱스 // argmin() 반대
    * flatten() # 평탄화, 1차원으로 변환
   
  * None 값을 numpy 에서는 np.nan 을 사용한다. (None 을 의미하는 numpy 객체)
    * 내부적으로는 float 으로 관리된다. broadcast 를 위해서# 25. 7. 10 (Thu)

* Numpy (Numeric python)
  * 1차원 배열 (벡터), 2차원 (행렬), 3차원 (시계열 데이터)
  * broadcast 방식으로 처리 속도를 높임
  * 일반 컨테이너 자료형은 데이터 변환이 번거로움
  * 자료형 ndarray (numpy dimension array)
    * 차원을 가지고 숫자와 문자열을 다루고, 동일 타입의 원소만 담겨야 함.
    * test = np.array([15, 20, 25, 30])
  * 평균 구하기: np.mean(test)
  * 수열을 만들어주는 메소드: np.arange(15, 31, 5) # 파이썬 내장 함수 range 와 비슷
  * list 는 데이터마다 방을 새로 추가하는 것이지만, ndarray 는 배열에 값을 추가하면 새로 배열을 만든다. // test = np.append(test, 35)
  * 5씩 더하기
    * [*map(lambda x: x+5, test)]
    * test + 5
  * numpy 사이즈 관한 변수들
    * itemsize # 원소가 차지하는 방의 byte 사이즈
    * dtype # 자료형
    * ndim # 차원
    * size # 원소의 전체 개수
    * shape # ndarray 의 구조 (5,) - 튜플
    * strides # 보폭 // 연산 속도가 빠를 수 있는 이유 // mmap 과 비교
  * dtype <U21 유니코드
    numpy.str_ 로 원소를 변환해줌.
  * ndarray.T 연산
    * numpy 배열 (ndarray) 전치 (transpose) 연산
      * 행과 열을 뒤바꾸는 연산임.
  * 차원이 맞지 않으면 1차원으로 결과를 리턴함
    ```python
    test = array([[[1, 2, 3]],
       [[4, 5, 6]],
       [[7, 8, 9]]])
    np.append(test, 40)
    # array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 40])
    ```
  * np.append(axis=0) 에서 axis 는 0 이 행, 1이 열이다.
  * append 분석
    (Case 1)
    ```python
    test =[[[1, 2, 3]],
       [[4, 5, 6]],
       [[7, 8, 9]]]

    test = np.array(test)
    test.shape # (3, 1, 1)

    test3 = np.array([[[1]],
     [[2]],
     [[3]]])
    test3.shape # (3, 1, 1)
    np.append(test, test3, axis=2)

    # array([[[1, 2, 3, 1]],
    #      [[4, 5, 6, 2]],
    #      [[7, 8, 9, 3]]]) 
    ```
    (3, 1, 3) 은 3개의 (1, 3) 배열 // (3, 1, 1) 3개의 (1, 1) 배열
    axis=2 는 가장 안쪽 축 (마지막 축.. 열 방향의 안쪽 원소에 대한 append)
    따라서 axis=2 는 각 (1, 3) 배열의 열 방향으로 데이터를 붙이는 것이다.
    3개의 원소에 열 하나를 추가하는 것

    (Case 2)
    ```python
    new_test = np.array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
    new_test.ndim # 2
    new_test.shape # (3, 3)

    new_test1 = np.array([[1,2,3]])
    # shape: (1, 3)

    np.append(new_test, new_test1.T, axis=1)
    # array([[1, 2, 3, 1],
    #   [4, 5, 6, 2],
    #   [7, 8, 9, 3]])
    ```
  * 유용한 메소드
    * np.ndarray.cumsum()
    * mean() # 평균
    * var() # 분산
    * std() # 표준편차
    * argmax() # 가장 큰 값의 인덱스 // argmin() 반대
    * flatten() # 평탄화, 1차원으로 변환
    * reshape() # ndarray 차원과 구조를 변경할 수 있다.
      ```python
      a = np.array(
        [
            [10, 20, 30],
            [40, 50, 60]
        ]
    )
    a.ndim
    a.shape
 
    a.reshape(-1, 3, 2) // -1 을 통해 자동으로 차원 변환을 시켜준다.
      ```
   
  * dtype=object 는 방마다 다른 자료형이 들어있음을 의미 (ndarray 를 사용할 이유가 없다)
  * None 값을 numpy 에서는 np.nan 을 사용한다. (None 을 의미하는 numpy 객체)
    * 내부적으로는 float 으로 관리된다. broadcast 를 위해서
    * 결측치 (데이터셋에서 값이 누락된 상태) 를 처리하기 위한 것
    * 결측치와 비교해서 np.inf (infinite) : 결측치와 구분하여 처리 과정에서 잘못된 값을 처리하기 위한 넘파이 객체
      * inf 값도 float 으로 관리된다. 
    
  * numpy 에서 처리가 가능한 숫자 자료형
    * int, uint, float, complex
   
  * a = np.arange(0, 3, 0.1, dtype='int') # 실수 -> 정수 형변환에 의한 데이터 손실
  * 형변환 np.array.astype('int')
  * 전문적인 과학 분야에서 복소수 연산이 사용되는 경우가 있음 (허수 + 실수) // complex
  * np bool 은 숫자 자료형이다.

* 복습
  * type(self) 는 클래스 내부에서 자신의 클래스 타입 (현재 인스턴스 클래스) 가 무엇인지 알고자할 때 사용
  * 상속 관계에서 부모 클래스와 다른 자식 클래스 이름을 독립적으로 사용할 때
  * super 키워드를 사용해서 중복된 코드를 줄이고, 자식 클래스에서 추가되는 내용만 별도로 작성하기
  * tuple 은 순서가 있는 것

* 더 공부해볼 것
  * numpy 구조에 대해서 : list 와 구분하여서 numpy 는 어떻게 데이터를 저장해서 효율적으로 처리가 가능한 것인지
    * 다차원의 데이터가 들어가도 1차원으로 평탄화하여 저장하고, 요청받은 차원에 따라 자료를 구성하여 리턴하는 방식
    * data, dimensions, strides 구조로된 1차원 데이터이기 때문에 빠르게 동작한다.
    

* 기타
  * int, str, list는 클래스이지만, 파이썬 내장 타입으로서 특별히 소문자 이름을 갖는 클래스
  * 내장 파이썬의 함수는 자료형을 가리지 않고 실행 가능 (메소드와 구분)
    * test = np.array([15, 20, 25, 30])
    * sorted(test) # [np.int64(15), np.int(20) ...] 결과는 list 로 반환함.
  * Scalar: 변하지 않는 숫자 (상수)
  * Vector: 선과 같은 형태, 행이 n 개이고 열이 1개인 형태
    * np.zeros(), np.ones() // 영벡터, 일벡터
  * Matrix: 면.. 여러개의 벡터가 모여서 이룬 하나의 행렬을 의미
