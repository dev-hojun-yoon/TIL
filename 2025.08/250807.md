# 25. 8. 7 (Thurs)

* ElasticSearch
  * 인덱스를 생성할 때 PUT 메소드를 사용한다.
  * POST /{인덱스명}/_doc 메소드 호출로 문서를 생성
  * 전체 중에 일부 데이터만 수정해야하는 경우
    ```
    POST /my-index3/_update/12
    {
      "doc": {
        "document_number": 4
      }
    }
    ```
  * 전체 데이터를 수정하는 경우 (나머지 필드가 모두 날라가고 document_number 필드만 남아 있음
    ```
    PUT /my_index3/_doc/{id}
    {
      "document_number": 4
    }
    ```
  * unix time 을 지정하였지만, 별도로 형 지정을 하지 않으면 long type 으로 저장
  * name 은 string 으로 지정하였는데 아래와 같이 text, keyword 가 모두 커버가 가능하도록 지정됨.
    ```
    "name": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        }
    ```
  * 복합 자료형도 심플자료형과 같은 방식으로 검색한다.
  * object 타입은 세부 요소가 모두 같은 타입으로 통일돼야 한다.
  * object 와 nested 타입의 차이점
    * nested 데이터 검색 예시 (인덱스 내의 별도의 doc 으로 관리횐다.) // 내부적으로 doc 안에 평탄화되는 object 와 비교
      부득이하게 students 필드를 doc 안의 doc 으로 관리해야 하는 경우
      ```
      PUT woorifisa_nested_test
      {
        "mappings": {
        "properties": {
          "students": {
            "type": "nested",
            "properties": {
              "name": {
                "type": "keyword"
              },
              "age": {
                "type": "long"
              }
            }
          }
        }
      }
      }

      # 검색 방법
      GET woorifisa_nested_test/_search
      {
        "query": {
          "nested": {
            "path": "student",
            "query": {
              "match": {
                "student.name": "신짱구"
              }
            }
          }
        }
      }
      ```
  * 모든 인덱스는 settings / mappings 2개의 정보 단위를 갖고 있음.
    * mappings : 문서가 어떻게 색인되고 저장되는지 정의 / SQL 자료형
  * 필드 타입
    * 심플 타입: text, keyword, date, long, double, boolean, ip
    * 계층 구조 지원 타입: object, nested
    * 그 외 타입: geo_point, geo_shape
  * 미리 명시적으로 타입을 지정한 경우 검색 시 주의
    * 원본을 그대로 저장하는데,
    * 타입은 정수형인데 40.6 데이터를 넣었을 때 40까지만 검색이 가능하므로 40.6 으로 조회는 불가능하니 주의
  * 검색 방식은 URI 검색과 Request Body 검색의 2가지 방법이 있음
  * 검색을 위한 query
    * term 쿼리와 match 쿼리
      * term (정확한 값)
        * 관련 타입 : keyword / numeric / boolean
      * match (단어 기반 / 토큰화)
        * 관련 타입 : text
    * Query DSL (domain specific language) : 쿼리를 통해 검색하는 방식
      * match (full text)
        * match_all, match, match_phrase, query_string
        * match_all 은 모든 문서에서 조회하는 것으로 생략 가능
        * match : text 타입 필드에서 해당 문자열이 포함되어 있는지 확인
        * query_string : URI 요청 방식과 유사 // 주소줄에 달아보내는 것과 같은 방식 동작 - * 모든문자, ? 한글자
          * 패턴 검색 등
            ```
            GET test/_search
            {
              "query": {
                "query_string": {
                  "default_field": "address",
                  "query" : "h*"
                }
              }
            }
            ```
        * match_phrase 는 순서대로 값을 탐색
          * 상암 맛집, 상암 0동 맛집, 상암 mbc 근처 맛집
            ```
            GET test/_search
            {
              "query": {
                "match_phrase": {
                  "address":
                  { 
                    "query" : "Lane 880", // 880 _ _ Lane
                    "slop" : 2 // slop 
                  }
                }
              }
            }
            ```
      * bool query
        * must, must_not, should, filter
          * should: 포함하는 키워드에 대해서 점수를 높여준다.
          * filter : must와 동일한 결과, filter 이하의 조건은 점수를 계산하지 않아서 must 에 비해 빠름
      * 값 비교 query (range)
        ```
          # balance 가 30000 달러를 넘는 사람
          # >=   range 키워드로 탐색
          # gt(>), lt(<), gte(>=), lte(<=), must(=), must_not(!=) 
          GET test/_search
          {
            "query": {
              "bool": {
                "must": [
                  {"range": {
                    "balance": {
                      "gte": 30000
                    } 
                  }}
                ]
              }
            }
          }
        ```
    * 여러개 쿼리를 한번에 작업하고 싶으면 -> _bulk
      * POST _bulk // default 인덱스는 test
      * 개행문자가 삽입되지 않도록 주의
      * GET test/_mappings, GET test/_settings 으로 세팅 내용 확인 가능
    * match 구문 안에서 띄어쓰기를 기준이나 OR 조건으로 텍스트를 구분하여 점수 알고리즘을 바탕으로 _score 를 계산
      * 점수 알고리즘
        * TF-IDF (term frequency-inverse document frequency)
        * 문서의 길이
        * Norms (Normalization) : 필드의 길이, 빈도 등을 기준으로 점수 조정
        * BM25 : 필드 길이, 빈도, 검색어 빈도를 종합적으로 고려
        * 다양한 문서에서 해당 문자열이 많이 등장하는 경우에는 점수 상승
    * 완전일치 검색은 match_phrase, slop 을 통해 쿼리를 구성할 수 있음
      * query: lazy dog // slop : 1 이면
      * 결과에 lazy jumping dog 값도 검색될 수 있음
    * ctrl + I 를 통해 kibana 정렬 가능
    * 분석기는 텍스트 분석 과정을 처리하는 기능을 의미 (**캐릭터 필터, 토크나이저, 토큰 필터로 구성**)
    * 기본 애널라이저
      ```
      POST _analyze
       {
         "analyzer": "standard",
         "text": "Hello, HELLO, World!"
       }
      ```
    * html strip 캐릭터 필드 적용
      * html 태그를 분석할 수 있음
    * mapping 캐릭터 필터 : key-value 구분
    * 사용자 정의 캐릭터 필터
      ```
      PUT my-index-000001
      {
        "settings": {
          "analysis": {
            "analyzer": {
              "my_analyzer": {
                "tokenizer": "standard",
                "char_filter": [
                  "my_char_filter"
                ]
              }
            },
            "char_filter": {
              "my_char_filter": {
                "type": "pattern_replace",
                "pattern": "(\\d+)-(?=\\d)",
                "replacement": "$1_"
              }
            }
          }
        }
      }

      POST my-index-000001/_analyze
      {
        "analyzer": "my_analyzer",
        "text": "My credit card is 123-456-789"
      }
      ```
      캐릭터 필터는 전처리 과정이고 이 데이터를 토큰나이저로 전달
    * 토큰나이징은 보통 ngram 을 사용함.
      * 들어오는 문자열을 n 개의 집합으로 끊음
    * 토큰 필터 중에는 (snowball) 캐릭터 필터, 토큰나이저, 토큰 필터를 모두 지정해줘야 하는 경우도 있음
    * 동의어 관리
      ```
      # https://www.elastic.co/docs/reference/text-analysis/analysis-synonym-tokenfilter
      "filter": {
        "synonyms_filter": {
          "type": "synonym",
          "synonyms_path": "analysis/synonym-set.txt"
        }
      }
      
      // config/analysis/my-synonym.txt
      // pc, mac, computer, ibm, labtop, notebook
      // 서울시, 서울특별시, 서울, 서울 특별시
      // 경상북도 => 경북 // 세종시, 세종특별시 => 세종
      ```
      ```
    * (주의) 관련 인덱스를 먼저 생성해야 함
    * synonym 예시
      ```
      PUT /my_synonym_index
       {
         "settings": {
           "analysis": {
            "filter": {
               "synonym_filter": {
                 "type": "synonym",
                 "synonyms_path": "analysis/my-synonym.txt"
               }
             },
             "analyzer": {
               "my_synonym_analyzer": {
                 "tokenizer": "standard",
                 "filter": [
                   "lowercase",
                   "synonym_filter"
                 ]
               }
             }
           }
         },
         "mappings": {
           "properties": {
             "title": {
               "type": "text",
               "analyzer": "my_synonym_analyzer"
             }
           }
         }
       }
       
         PUT /my_synonym_index/_doc/1
         {
           "text": "I bought a pc, mac, ibm. in 서울시 세종시 경상북도"
         }
       
         POST /my_synonym_index/_analyze
         {
           "analyzer": "my_synonym_analyzer",
           "text": "I bought a pc, mac, ibm. in 서울시 세종시 경상북도"
         }
    ```
