# 25. 8. 13 (Wed)

* logstash
  * config > logstash-sample.conf 에서 파이프라인을 정의한다.
  * logstash 는 단방향으로 동작
  * grok pattern
    * https://github.com/elastic/logstash/blob/v1.4.0/patterns/grok-patterns
    * logstash filter 를 통해 비정형데이터를 정형 데이터로 변경할 수 있는데, 이 때 정규식을 이용하여 정형화하는 방법이 grok pattern
    * 55.3.244.1 GET /index.html 15824 0.043 hello world!
    * %{IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration} %{GREEDYDATA:custom}
  * pipelines.yml
    * pipeline.id: 파이프라인 이름
    * path.cofing: 파이프라인의 config 경로
    * logstash 는 이 파일부터 참조한다.
    * 같은 파일을 바라보도록 파이프라인을 여러개 작성하면 그중에 1개만 동작합니다. log파일의 마지막 글자 위치(offset)를 기억했다가 그 다음 입력을 받기 때문 
    * path.config 는 동일한 파일을 참조할 수 없다. 파이프라인은 상대경로로 작성해야 한다.
      * 예시: ./config/logstash/config/logstash-pipeline-5.conf
  * filebeat
    * 각 서버에 logstash 를 설치해서 filebeat 를 대체할 수 있음
    * 그러나, 파일 감시 (테일링) 기능의 안정성과 효율성 측면에서 filebeat 가 logstash 보다 훨씬 유리하다는 의미
    * filebeat 는 Go 로 작성된 경량 에이전트라 CPU / 메모리 사용량이 매우 적다.
    * LogStash 는 JVM 기반이라 기본적으로 메모리 사용량이 많고 단순 파일 읽기에도 비교적 무거움
  * fluentd
    * logstash 대체용도로 쓰기도 하고, 함께 쓰이기도 한다.
    * 함께 쓰일 때 filebeat 와 비교하면,
      * 단순 로그 수집을 비교했을 때, filebeat 가 fluentd 대비 20~50 % 더 낮은 CPU 사용량과 10~30% 더 높은 처리량
      * 그러나 복잡한 변환과 / 멀티 출력이 필요하면 fluentd 쪽이 유리
    * C core + ruby 플러그인 구조로 Logstash 없이도 수집 / 가공 / 전송까지 한번에 처리가 가능하다.

