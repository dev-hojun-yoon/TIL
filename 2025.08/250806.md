# 25. 8. 6 (Wed)

* docker (remind)
  * docker image prune -a : 사용하지 않는 이미지를 삭제한다.
* Github Action
  * Github Action 으로 CI/CD 를 구축할 때 1개 workflow 는 1개의 로직만 담당하도록 설정해서 디버깅이 용이하도록 권장
  * create status badge 를 readme 에 올려놔서 상태를 확인할 수도 있다.
* ELK
  * ElasticSearch, Logstash, Kibana
    * 벡터 DB 를 지원함, 문자 사이의 유사도를 지원하는 벡터 DB 자료형으로 저장이 가능하여 LLM 쪽과 관련하여 많이 사용되고 있음
    * 8 버전부터 유료화 무료버전은 OpenSearch 에서 지원
    * JVM 기반으로 동작하여 초반 빌드에 시간이 소요된다.
  * NoSQL
    * key-value
    * column_family
    * Graph
    * Document (ElasticSearch 가 여기에 해당)
  * 클러스터 구성
    * 클러스터는 보통 홀수 개의 서버 (노드) 를 구성한다. 여러개의 노드 중 자동으로 마스터 노드를 선정도 가능하고, 직접 지정도 가능
  * 용어 정리 (RDB 와 비교)
    * **인덱스 = 데이터베이스**
      * 인덱스는 문서가 저장되는 논리적 공간 / 검색 인덱스 역할도 포함
    * **샤드 = 파티션**
      * 문서를 인덱싱할 때 (동기화 과정) 해당 문서가 어떤 샤드에 저장될 지 자동으로 결정
        * 문서의 _id 갑을 기준으로 해시 함수를 적용해서 어떤 primary shard 에 저장될 지 결정
      * 샤드는 더 이상 분해되지 않는 단위
      * 데이터를 자동으로 나누어 저장하며, 나뉜 단위가 샤드이다. 각각의 샤드는 하나의 루씬 인스턴스이고, 실제 검색 / 색인 작업은 샤드 단위로 수행된다. primary shard / replica shard 로 구분됨.
      * 데이터를 분산 저장하는 단위
      * MySQL 파티션과 유사하지만, MySQL 파티션은 주로 하나의 서버 내에서 물리적 구분을 위해 사용함.
    * 타입 = 테이블
      * ES 6.x 까지는 한 인덱스에 여러 타입을 둘 수 있었지만,
      * 7.x 부터는 타입 개념이 사라짐.
    * 문서 = 행
      * JSON 형식의 데이터 한 건이 문서
    * 필드 = 열
      * 문서 내의 키-값 쌍
    * 매핑 = 스키마
      * ElasticSearch 는 동적 매핑을 지원하기 때문에, 인덱스에 document 가 새로 추가했을 때, 자동으로 매핑됨.
      * 예시) GET books/_mapping
      * 데이터 타입, 분석기 등을 정의하는 구조
  * ElasticSearch 추가 정리
    * JOIN 기능이 없음, 중복된 데이터가 저장되지 않도록 주의하고, 필요한 데이터를 JSON 에 모두 저장하면 됨.
    * HTTP 를 통해 JSON 형식의 RESTful API 사용
    * (참고) REST API
      * 예전에는 동작마다 요청 endpoint 를 새로 만들었는데, (동사)
      * 명사로 표현하고 메소드로 구분 (GET / POST / PUT / PATCH / DELETE)
    * 인덱스에 문서를 추가
      * POST /my-index/_doc
    * mappings -> 자료형 text, keyword 타입이 상이함 주의 // ES 는 기본 동적 매핑
      * text: 글자마다 공백으로 구분해서 저장해서 검색이 잘 되도록 지원
      * keyword: 공백 단위로 저장하면 공간이 부족할 수 있으니, 문자열 통짜로 저장하는 방식
    * create 성격은 -> POST
    * document 번호를 직접 지정해서 값을 넣거나 수정할 때 PUT, PATCH 사용
      * 예시) PUT /my-index/_doc/1
      * PUT 은 문서 전체 수정
      * PATCH 는 문서 일부 수정 (Rest API 쪽에서는)
        * ES 에서는 PATCH 가 없음. POST + update 메소드를 사용
          * 
    * "tags": ["rocky", true, 3.14, "2"] // 리스트 단위로 매핑할 때는 안에 있는 자료형은 통일해서 사용해야 한다.
    * GET
      * GET /my-index/_search : 따로 조건이 없으면 인덱스 내 전체 데이터 반환
      * 검색 방법
        * GET /my-index/_search?q="tundra"
        * GET /my-index/_search?q=id:"mountain2"
        * match 쿼리
          검색 시에도 본문을 담아서 요청을 보낸다면, GET / POST 중 사용 가능합니다.
          ```
          POST /my-index/_search
          {
              "query": {
                  "match": {
                      "id": "mountain2"
                  }
              }
          }
          ```
    * DELETE
      * 문서 하나를 삭제 DELETE /my-index/_doc/1
      * 인덱스 자체 삭제 DELETE /my-index
    * 자료형을 고정해서 index를 만들기
      * text: 들어오는 문자열을 검색하기 좋게 쪼개서 저장합니다.
      * keyword: 들어오는 문자열을 통으로 저장합니다.
        ```
        PUT /my-index
        {
           "mappings": {
              "properties": {
                "address": {
                  "type": "text"
                },
                "age": {
                  "type": "long"
                },
                "name": {
                  "type": "keyword"
                }
              }
           }
        }

        PUT /my-index/_doc/1
        {
          "name": "HJ",
          "age": 20,
          "address": "서울시 강서구"
        }

        # name 필드는 keyword 자료형이므로 통째로 색인 - 완전일치 아니면 검색 불가
        ```
    * analyze : 입력된 문자열이 어떻게 토큰화되어 있는지 확인 가능
      ```
      POST _analyze
     {
       "analyzer": "standard",
       "text": "서울시 강서구"
     }
      ```
    * ElasticSearch 는 전문 검색을 지원한다.
      * 특정 필드, 인덱스에 제한 없이 검색을 할 수 있다.
    * 역색인 개념 (Inverted Index)
      * 데이터를 저장할 때부터 색인되어 저장되기 때문에, 이미 색인된 데이터를 바탕으로 빠르게 검색할 수 있는 것임
      * 인서트, 업데이트 시에 시간이 걸릴 수 있음에 주의
    * 전체적인 클러스터 성능 향상을 위해 비용 소모가 큰 "롤백"과 "트랜잭션" 기능이 없다.
    * 노드 조회 : GET _cat/nodes
